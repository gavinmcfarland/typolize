import postcss from 'postcss';

var cloneRule = ((decl, dir) => {
  const rule = Object(decl.parent).type === 'rule' ? decl.parent.clone({
    raws: {}
  }).removeAll() : postcss.rule({
    selector: '&'
  });
  rule.selectors = rule.selectors.map(selector => `${selector}:dir(${dir})`);
  return rule;
});

const matchLogicalBorderSide = /^border-(block|block-start|block-end|inline|inline-start|inline-end)(-(width|style|color))?$/i;
var transformBorder = {
  // border-block
  'border-block': (decl, values) => [decl.clone({
    prop: `border-top${decl.prop.replace(matchLogicalBorderSide, '$2')}`,
    value: values[0]
  }), decl.clone({
    prop: `border-bottom${decl.prop.replace(matchLogicalBorderSide, '$2')}`,
    value: values[0]
  })],
  // border-block-start
  'border-block-start': decl => {
    decl.prop = `border-top${decl.prop.replace(matchLogicalBorderSide, '$2')}`;
  },
  // border-block-end
  'border-block-end': decl => {
    decl.prop = `border-bottom${decl.prop.replace(matchLogicalBorderSide, '$2')}`;
  },
  // border-inline
  'border-inline': (decl, values, dir) => {
    const ltrDecls = [decl.clone({
      prop: `border-left${decl.prop.replace(matchLogicalBorderSide, '$2')}`,
      value: values[0]
    }), decl.clone({
      prop: `border-right${decl.prop.replace(matchLogicalBorderSide, '$2')}`,
      value: values[1] || values[0]
    })];
    const rtlDecls = [decl.clone({
      prop: `border-right${decl.prop.replace(matchLogicalBorderSide, '$2')}`,
      value: values[0]
    }), decl.clone({
      prop: `border-left${decl.prop.replace(matchLogicalBorderSide, '$2')}`,
      value: values[1] || values[0]
    })];
    const isLTR = 1 === values.length || 2 === values.length && values[0] === values[1];
    return isLTR ? ltrDecls : dir === 'ltr' ? ltrDecls : dir === 'rtl' ? rtlDecls : [cloneRule(decl, 'ltr').append(ltrDecls), cloneRule(decl, 'rtl').append(rtlDecls)];
  },
  // border-inline-start
  'border-inline-start': (decl, values, dir) => {
    const ltrDecl = decl.clone({
      prop: `border-left${decl.prop.replace(matchLogicalBorderSide, '$2')}`
    });
    const rtlDecl = decl.clone({
      prop: `border-right${decl.prop.replace(matchLogicalBorderSide, '$2')}`
    });
    return dir === 'ltr' ? ltrDecl : dir === 'rtl' ? rtlDecl : [cloneRule(decl, 'ltr').append(ltrDecl), cloneRule(decl, 'rtl').append(rtlDecl)];
  },
  // border-inline-end
  'border-inline-end': (decl, values, dir) => {
    const ltrDecl = decl.clone({
      prop: `border-right${decl.prop.replace(matchLogicalBorderSide, '$2')}`
    });
    const rtlDecl = decl.clone({
      prop: `border-left${decl.prop.replace(matchLogicalBorderSide, '$2')}`
    });
    return dir === 'ltr' ? ltrDecl : dir === 'rtl' ? rtlDecl : [cloneRule(decl, 'ltr').append(ltrDecl), cloneRule(decl, 'rtl').append(rtlDecl)];
  }
};

const logicalRadii = /^(border-)(end-end|end-start|start-end|start-start)(-radius)$/i;
const ltrRadii = {
  'end-end': 'bottom-right',
  'end-start': 'bottom-left',
  'start-end': 'top-right',
  'start-start': 'top-left'
};
const rtlRadii = {
  'end-end': 'bottom-left',
  'end-start': 'bottom-right',
  'start-end': 'top-left',
  'start-start': 'top-right'
};
var transformBorderRadius = ((decl, values, dir) => {
  const ltrDecl = decl.clone({
    prop: decl.prop.replace(logicalRadii, ($, prefix, direction, suffix) => `${prefix}${ltrRadii[direction]}${suffix}`)
  });

  if (dir === 'ltr') {
    return ltrDecl;
  }

  const rtlDecl = decl.clone({
    prop: decl.prop.replace(logicalRadii, ($, prefix, direction, suffix) => `${prefix}${rtlRadii[direction]}${suffix}`)
  });

  if (dir === 'rtl') {
    return rtlDecl;
  }

  return [cloneRule(decl, 'ltr').append(ltrDecl), cloneRule(decl, 'rtl').append(rtlDecl)];
});

var reduceValues = (values => {
  const reducedValues = values.slice(); // reduce [A, B, C, B] to [A, B, C]

  if (reducedValues.length === 4 && reducedValues[3] === reducedValues[1]) {
    reducedValues.pop();
  } // reduce [A, B, A] to [A, B]


  if (reducedValues.length === 3 && reducedValues[2] === reducedValues[0]) {
    reducedValues.pop();
  } // reduce [A, A] to [A]


  if (reducedValues.length === 2 && reducedValues[1] === reducedValues[0]) {
    reducedValues.pop();
  }

  return reducedValues;
});

var transformDirectionalShorthands = ((decl, values, dir) => {
  if ('logical' !== values[0]) {
    return null;
  } // get logical directions as all, inline, block-end, then inline-end


  const [, all, inline, blockEnd, inlineEnd] = values; // get left-to-right relative directions from logical directions as:
  // → top from all
  // → right from inline-end, inline, or all
  // → bottom from block-end, block, or all
  // → left from inline, or all

  const ltrValues = reduceValues([all, inlineEnd || inline || all, blockEnd || all, inline || all]);
  const ltrDecl = decl.clone({
    value: ltrValues.join(' ')
  }); // return the ltr values if the values are flow agnostic (where no second inline value was needed)

  const isFlowAgnostic = ltrValues.length < 4;

  if (isFlowAgnostic || dir === 'ltr') {
    return ltrDecl;
  } // get right-to-left relative directions from logical directions as:
  // → top from all
  // → right from inline, or all
  // → bottom from block-end, block, or all
  // → left from inline-end, inline, or all


  const rtlValues = reduceValues([all, inline || all, blockEnd || all, inlineEnd || inline || all]);
  const rtlDecl = decl.clone({
    value: rtlValues.join(' ')
  });

  if (dir === 'rtl') {
    return rtlDecl;
  }

  return [cloneRule(decl, 'ltr').append(ltrDecl), cloneRule(decl, 'rtl').append(rtlDecl)];
});

var transformFloat = ((decl, values, dir) => {
  const lDecl = decl.clone({
    value: 'left'
  });
  const rDecl = decl.clone({
    value: 'right'
  });
  return /^inline-start$/i.test(decl.value) ? dir === 'ltr' ? lDecl : dir === 'rtl' ? rDecl : [cloneRule(decl, 'ltr').append(lDecl), cloneRule(decl, 'rtl').append(rDecl)] : /^inline-end$/i.test(decl.value) ? dir === 'ltr' ? rDecl : dir === 'rtl' ? lDecl : [cloneRule(decl, 'ltr').append(rDecl), cloneRule(decl, 'rtl').append(lDecl)] : null;
});

var transformInset = ((decl, values, dir) => {
  if ('logical' !== values[0]) {
    return [decl.clone({
      prop: 'top',
      value: values[0]
    }), decl.clone({
      prop: 'right',
      value: values[1] || values[0]
    }), decl.clone({
      prop: 'bottom',
      value: values[2] || values[0]
    }), decl.clone({
      prop: 'left',
      value: values[3] || values[1] || values[0]
    })];
  }

  const isLTR = !values[4] || values[4] === values[2];
  const ltrDecls = [decl.clone({
    prop: 'top',
    value: values[1]
  }), decl.clone({
    prop: 'left',
    value: values[2] || values[1]
  }), decl.clone({
    prop: 'bottom',
    value: values[3] || values[1]
  }), decl.clone({
    prop: 'right',
    value: values[4] || values[2] || values[1]
  })];
  const rtlDecls = [decl.clone({
    prop: 'top',
    value: values[1]
  }), decl.clone({
    prop: 'right',
    value: values[2] || values[1]
  }), decl.clone({
    prop: 'bottom',
    value: values[3] || values[1]
  }), decl.clone({
    prop: 'left',
    value: values[4] || values[2] || values[1]
  })];
  return isLTR || dir === 'ltr' ? ltrDecls : dir === 'rtl' ? rtlDecls : [cloneRule(decl, 'ltr').append(ltrDecls), cloneRule(decl, 'rtl').append(rtlDecls)];
});

var transformResize = (decl => /^block$/i.test(decl.value) ? decl.clone({
  value: 'vertical'
}) : /^inline$/i.test(decl.value) ? decl.clone({
  value: 'horizontal'
}) : null);

var matchSide = /^(inset|margin|padding)(?:-(block|block-start|block-end|inline|inline-start|inline-end|start|end))$/i;

var matchInsetPrefix = /^inset-/i;

var cloneDecl = ((decl, suffix, value) => decl.clone({
  prop: `${decl.prop.replace(matchSide, '$1')}${suffix}`.replace(matchInsetPrefix, ''),
  value
}));

var transformSide = {
  // inset-block, margin-block, padding-block
  'block': (decl, values) => [cloneDecl(decl, '-top', values[0]), cloneDecl(decl, '-bottom', values[1] || values[0])],
  // inset-block-start, margin-block-start, padding-block-start
  'block-start': decl => {
    decl.prop = decl.prop.replace(matchSide, '$1-top').replace(matchInsetPrefix, '');
  },
  // inset-block-end, margin-block-end, padding-block-end
  'block-end': decl => {
    decl.prop = decl.prop.replace(matchSide, '$1-bottom').replace(matchInsetPrefix, '');
  },
  // inset-inline, margin-inline, padding-inline
  'inline': (decl, values, dir) => {
    const ltrDecls = [cloneDecl(decl, '-left', values[0]), cloneDecl(decl, '-right', values[1] || values[0])];
    const rtlDecls = [cloneDecl(decl, '-right', values[0]), cloneDecl(decl, '-left', values[1] || values[0])];
    const isLTR = 1 === values.length || 2 === values.length && values[0] === values[1];
    return isLTR ? ltrDecls : dir === 'ltr' ? ltrDecls : dir === 'rtl' ? rtlDecls : [cloneRule(decl, 'ltr').append(ltrDecls), cloneRule(decl, 'rtl').append(rtlDecls)];
  },
  // inset-inline-start, margin-inline-start, padding-inline-start
  'inline-start': (decl, values, dir) => {
    const ltrDecl = cloneDecl(decl, '-left', decl.value);
    const rtlDecl = cloneDecl(decl, '-right', decl.value);
    return dir === 'ltr' ? ltrDecl : dir === 'rtl' ? rtlDecl : [cloneRule(decl, 'ltr').append(ltrDecl), cloneRule(decl, 'rtl').append(rtlDecl)];
  },
  // inset-inline-end, margin-inline-end, padding-inline-end
  'inline-end': (decl, values, dir) => {
    const ltrDecl = cloneDecl(decl, '-right', decl.value);
    const rtlDecl = cloneDecl(decl, '-left', decl.value);
    return dir === 'ltr' ? ltrDecl : dir === 'rtl' ? rtlDecl : [cloneRule(decl, 'ltr').append(ltrDecl), cloneRule(decl, 'rtl').append(rtlDecl)];
  }
};

var matchSize = /^(min-|max-)?(block|inline)-(size)$/i;

var transformSize = (decl => {
  decl.prop = decl.prop.replace(matchSize, ($0, minmax, flow) => `${minmax || ''}${'block' === flow ? 'height' : 'width'}`);
});

var transformTextAlign = ((decl, values, dir) => {
  const lDecl = decl.clone({
    value: 'left'
  });
  const rDecl = decl.clone({
    value: 'right'
  });
  return /^start$/i.test(decl.value) ? dir === 'ltr' ? lDecl : dir === 'rtl' ? rDecl : [cloneRule(decl, 'ltr').append(lDecl), cloneRule(decl, 'rtl').append(rDecl)] : /^end$/i.test(decl.value) ? dir === 'ltr' ? rDecl : dir === 'rtl' ? lDecl : [cloneRule(decl, 'ltr').append(rDecl), cloneRule(decl, 'rtl').append(lDecl)] : null;
});

function splitByComma(string, isTrimmed) {
  return splitByRegExp(string, /^,$/, isTrimmed);
}
function splitBySpace(string, isTrimmed) {
  return splitByRegExp(string, /^\s$/, isTrimmed);
}

function splitByRegExp(string, re, isTrimmed) {
  const array = [];
  let buffer = '';
  let split = false;
  let func = 0;
  let i = -1;

  while (++i < string.length) {
    const char = string[i];

    if (char === '(') {
      func += 1;
    } else if (char === ')') {
      if (func > 0) {
        func -= 1;
      }
    } else if (func === 0) {
      if (re.test(char)) {
        split = true;
      }
    }

    if (split) {
      if (!isTrimmed || buffer.trim()) {
        array.push(isTrimmed ? buffer.trim() : buffer);
      }

      if (!isTrimmed) {
        array.push(char);
      }

      buffer = '';
      split = false;
    } else {
      buffer += char;
    }
  }

  if (buffer !== '') {
    array.push(isTrimmed ? buffer.trim() : buffer);
  }

  return array;
}

var transformTransition = ((decl, notValues, dir) => {
  const ltrValues = [];
  const rtlValues = [];
  splitByComma(decl.value).forEach(value => {
    let hasBeenSplit = false;
    splitBySpace(value).forEach((word, index, words) => {
      if (word in valueMap) {
        hasBeenSplit = true;
        valueMap[word].ltr.forEach(replacement => {
          const clone = words.slice();
          clone.splice(index, 1, replacement);

          if (ltrValues.length && !/^,$/.test(ltrValues[ltrValues.length - 1])) {
            ltrValues.push(',');
          }

          ltrValues.push(clone.join(''));
        });
        valueMap[word].rtl.forEach(replacement => {
          const clone = words.slice();
          clone.splice(index, 1, replacement);

          if (rtlValues.length && !/^,$/.test(rtlValues[rtlValues.length - 1])) {
            rtlValues.push(',');
          }

          rtlValues.push(clone.join(''));
        });
      }
    });

    if (!hasBeenSplit) {
      ltrValues.push(value);
      rtlValues.push(value);
    }
  });
  const ltrDecl = decl.clone({
    value: ltrValues.join('')
  });
  const rtlDecl = decl.clone({
    value: rtlValues.join('')
  });
  return ltrValues.length && dir === 'ltr' ? ltrDecl : rtlValues.length && dir === 'rtl' ? rtlDecl : ltrDecl.value !== rtlDecl.value ? [cloneRule(decl, 'ltr').append(ltrDecl), cloneRule(decl, 'rtl').append(rtlDecl)] : null;
});
const valueMap = {
  // Logical Height and Logical Width
  'block-size': {
    ltr: ['height'],
    rtl: ['height']
  },
  'inline-size': {
    ltr: ['width'],
    rtl: ['width']
  },
  // Flow-relative Margins
  'margin-block-end': {
    ltr: ['margin-bottom'],
    rtl: ['margin-bottom']
  },
  'margin-block-start': {
    ltr: ['margin-top'],
    rtl: ['margin-top']
  },
  'margin-block': {
    ltr: ['margin-top', 'margin-bottom'],
    rtl: ['margin-top', 'margin-bottom']
  },
  'margin-inline-end': {
    ltr: ['margin-right'],
    rtl: ['margin-left']
  },
  'margin-inline-start': {
    ltr: ['margin-left'],
    rtl: ['margin-right']
  },
  'margin-inline': {
    ltr: ['margin-left', 'margin-right'],
    rtl: ['margin-left', 'margin-right']
  },
  // Flow-relative Offsets
  'inset-block-end': {
    ltr: ['bottom'],
    rtl: ['bottom']
  },
  'inset-block-start': {
    ltr: ['top'],
    rtl: ['top']
  },
  'inset-block': {
    ltr: ['top', 'bottom'],
    rtl: ['top', 'bottom']
  },
  'inset-inline-end': {
    ltr: ['right'],
    rtl: ['left']
  },
  'inset-inline-start': {
    ltr: ['left'],
    rtl: ['right']
  },
  'inset-inline': {
    ltr: ['left', 'right'],
    rtl: ['left', 'right']
  },
  'inset': {
    ltr: ['top', 'right', 'bottom', 'left'],
    rtl: ['top', 'right', 'bottom', 'left']
  },
  // Flow-relative Padding
  'padding-block-end': {
    ltr: ['padding-bottom'],
    rtl: ['padding-bottom']
  },
  'padding-block-start': {
    ltr: ['padding-top'],
    rtl: ['padding-top']
  },
  'padding-block': {
    ltr: ['padding-top', 'padding-bottom'],
    rtl: ['padding-top', 'padding-bottom']
  },
  'padding-inline-end': {
    ltr: ['padding-right'],
    rtl: ['padding-left']
  },
  'padding-inline-start': {
    ltr: ['padding-left'],
    rtl: ['padding-right']
  },
  'padding-inline': {
    ltr: ['padding-left', 'padding-right'],
    rtl: ['padding-left', 'padding-right']
  },
  // Flow-relative Borders
  'border-block-color': {
    ltr: ['border-top-color', 'border-bottom-color'],
    rtl: ['border-top-color', 'border-bottom-color']
  },
  'border-block-end-color': {
    ltr: ['border-bottom-color'],
    rtl: ['border-bottom-color']
  },
  'border-block-end-style': {
    ltr: ['border-bottom-style'],
    rtl: ['border-bottom-style']
  },
  'border-block-end-width': {
    ltr: ['border-bottom-width'],
    rtl: ['border-bottom-width']
  },
  'border-block-end': {
    ltr: ['border-bottom'],
    rtl: ['border-bottom']
  },
  'border-block-start-color': {
    ltr: ['border-top-color'],
    rtl: ['border-top-color']
  },
  'border-block-start-style': {
    ltr: ['border-top-style'],
    rtl: ['border-top-style']
  },
  'border-block-start-width': {
    ltr: ['border-top-width'],
    rtl: ['border-top-width']
  },
  'border-block-start': {
    ltr: ['border-top'],
    rtl: ['border-top']
  },
  'border-block-style': {
    ltr: ['border-top-style', 'border-bottom-style'],
    rtl: ['border-top-style', 'border-bottom-style']
  },
  'border-block-width': {
    ltr: ['border-top-width', 'border-bottom-width'],
    rtl: ['border-top-width', 'border-bottom-width']
  },
  'border-block': {
    ltr: ['border-top', 'border-bottom'],
    rtl: ['border-top', 'border-bottom']
  },
  'border-inline-color': {
    ltr: ['border-left-color', 'border-right-color'],
    rtl: ['border-left-color', 'border-right-color']
  },
  'border-inline-end-color': {
    ltr: ['border-right-color'],
    rtl: ['border-left-color']
  },
  'border-inline-end-style': {
    ltr: ['border-right-style'],
    rtl: ['border-left-style']
  },
  'border-inline-end-width': {
    ltr: ['border-right-width'],
    rtl: ['border-left-width']
  },
  'border-inline-end': {
    ltr: ['border-right'],
    rtl: ['border-left']
  },
  'border-inline-start-color': {
    ltr: ['border-left-color'],
    rtl: ['border-right-color']
  },
  'border-inline-start-style': {
    ltr: ['border-left-style'],
    rtl: ['border-right-style']
  },
  'border-inline-start-width': {
    ltr: ['border-left-width'],
    rtl: ['border-right-width']
  },
  'border-inline-start': {
    ltr: ['border-left'],
    rtl: ['border-right']
  },
  'border-inline-style': {
    ltr: ['border-left-style', 'border-right-style'],
    rtl: ['border-left-style', 'border-right-style']
  },
  'border-inline-width': {
    ltr: ['border-left-width', 'border-right-width'],
    rtl: ['border-left-width', 'border-right-width']
  },
  'border-inline': {
    ltr: ['border-left', 'border-right'],
    rtl: ['border-left', 'border-right']
  },
  // Flow-relative Corner Rounding
  'border-end-end-radius': {
    ltr: ['border-bottom-right-radius'],
    rtl: ['border-bottom-left-radius']
  },
  'border-end-start-radius': {
    ltr: ['border-bottom-left-radius'],
    rtl: ['border-bottom-right-radius']
  },
  'border-start-end-radius': {
    ltr: ['border-top-right-radius'],
    rtl: ['border-top-left-radius']
  },
  'border-start-start-radius': {
    ltr: ['border-top-left-radius'],
    rtl: ['border-top-right-radius']
  }
};

// tooling

const transforms = {
  // Flow-Relative Values
  'clear': transformFloat,
  'float': transformFloat,
  'resize': transformResize,
  'text-align': transformTextAlign,
  // Logical Height and Logical Width
  'block-size': transformSize,
  'max-block-size': transformSize,
  'min-block-size': transformSize,
  'inline-size': transformSize,
  'max-inline-size': transformSize,
  'min-inline-size': transformSize,
  // Flow-relative Margins
  'margin': transformDirectionalShorthands,
  'margin-inline': transformSide['inline'],
  'margin-inline-end': transformSide['inline-end'],
  'margin-inline-start': transformSide['inline-start'],
  'margin-block': transformSide['block'],
  'margin-block-end': transformSide['block-end'],
  'margin-block-start': transformSide['block-start'],
  // Flow-relative Offsets
  'inset': transformInset,
  'inset-inline': transformSide['inline'],
  'inset-inline-end': transformSide['inline-end'],
  'inset-inline-start': transformSide['inline-start'],
  'inset-block': transformSide['block'],
  'inset-block-end': transformSide['block-end'],
  'inset-block-start': transformSide['block-start'],
  // Flow-relative Padding
  'padding': transformDirectionalShorthands,
  'padding-inline': transformSide['inline'],
  'padding-inline-end': transformSide['inline-end'],
  'padding-inline-start': transformSide['inline-start'],
  'padding-block': transformSide['block'],
  'padding-block-end': transformSide['block-end'],
  'padding-block-start': transformSide['block-start'],
  // Flow-relative Borders
  'border-block': transformBorder['border-block'],
  'border-block-color': transformBorder['border-block'],
  'border-block-style': transformBorder['border-block'],
  'border-block-width': transformBorder['border-block'],
  'border-block-end': transformBorder['border-block-end'],
  'border-block-end-color': transformBorder['border-block-end'],
  'border-block-end-style': transformBorder['border-block-end'],
  'border-block-end-width': transformBorder['border-block-end'],
  'border-block-start': transformBorder['border-block-start'],
  'border-block-start-color': transformBorder['border-block-start'],
  'border-block-start-style': transformBorder['border-block-start'],
  'border-block-start-width': transformBorder['border-block-start'],
  'border-inline': transformBorder['border-inline'],
  'border-inline-color': transformBorder['border-inline'],
  'border-inline-style': transformBorder['border-inline'],
  'border-inline-width': transformBorder['border-inline'],
  'border-inline-end': transformBorder['border-inline-end'],
  'border-inline-end-color': transformBorder['border-inline-end'],
  'border-inline-end-style': transformBorder['border-inline-end'],
  'border-inline-end-width': transformBorder['border-inline-end'],
  'border-inline-start': transformBorder['border-inline-start'],
  'border-inline-start-color': transformBorder['border-inline-start'],
  'border-inline-start-style': transformBorder['border-inline-start'],
  'border-inline-start-width': transformBorder['border-inline-start'],
  // Flow-relative Corner Rounding
  'border-end-end-radius': transformBorderRadius,
  'border-end-start-radius': transformBorderRadius,
  'border-start-end-radius': transformBorderRadius,
  'border-start-start-radius': transformBorderRadius,
  // Four-Directional Shorthand Border Properties
  'border-color': transformDirectionalShorthands,
  'border-style': transformDirectionalShorthands,
  'border-width': transformDirectionalShorthands,
  // Transition helpers
  'transition': transformTransition,
  'transition-property': transformTransition
};
const transformsRegExp = new RegExp(`^(${Object.keys(transforms).join('|')})$`, 'i'); // properties whose values will not be split

const unsplitPropRegExp = /^(border-block|border-block-end|border-block-start|border-inline|border-inline-end|border-inline-start)$/i; // plugin

var index = postcss.plugin('postcss-logical-properties', opts => {
  opts = Object(opts);
  const preserve = Boolean(opts.preserve);
  const dir = !preserve && typeof opts.dir === 'string' ? /^rtl$/i.test(opts.dir) ? 'rtl' : 'ltr' : false;
  return root => {
    root.walkDecls(transformsRegExp, decl => {
      const parent = decl.parent;
      const values = unsplitPropRegExp.test(decl.prop) ? [decl.value] : splitBySpace(decl.value, true);
      const prop = decl.prop.toLowerCase();
      const replacer = transforms[prop](decl, values, dir);

      if (!replacer) {
        return;
      }

      [].concat(replacer).forEach(replacement => {
        if (replacement.type === 'rule') {
          parent.before(replacement);
        } else {
          decl.before(replacement);
        }
      });

      if (preserve) {
        return;
      }

      decl.remove();

      if (!parent.nodes.length) {
        parent.remove();
      }
    });
  };
});

export default index;
//# sourceMappingURL=index.esm.mjs.map
